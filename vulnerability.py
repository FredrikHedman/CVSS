#!/usr/bin/env python3
#
# Author: Fredrik Hedman <fredrik.hedman@noruna.se>
# Version: 1.15
# LICENSE: MIT LICENSE
#
"""The VulnerabilityVector class encapsulates the concept of a
vulnerability vector as decribed in the
[CVSS Guide.](http://www.first.org/cvss/cvss-guide.html)

Intialize the class with a string conaining a vulnerability vector.
The operations help in checking, modifying and using the vector.

A vector is a list of components separated by a slash ("/").  Each
component is is a pair of values separated by a colon (":"). The first
value is the abbreviated metric name and the second value is the
abbreviated metric value.

The base, temporal, and environmental vectors are shown below with the
possible metric values listed within square brackets ([...])

* Base
"AV:[L,A,N]/AC:[H,M,L]/Au:[M,S,N]/C:[N,P,C]/I:[N,P,C]/A:[N,P,C]"

* Temporal
"E:[U,POC,F,H,ND]/RL:[OF,TF,W,U,ND]/RC:[UC,UR,C,ND]"

* Environmental
"CDP:[N,L,LM,MH,H,ND]/TD:[N,L,M,H,ND]/CR:[L,M,H,ND]/IR:[L,M,H,ND]/AR:[L,M,H,ND]"

The vector lists these metrics in a predetermined order.

When a temporal or environmental metric is not used it is assigned the
value "ND" (not defined).

A VulnerabilityVector is initialized with a string.

"""
import sys
from collections import OrderedDict

def parse_vector_template(txt):
    keys = [ k.split(':')[0] for k in txt.split('/') ]
    vals = [ k.split(':')[1][1:-1].split(',') for k in txt.split('/') ]
    return OrderedDict(zip(keys, vals))

BS = "AV:[L,A,N]/AC:[H,M,L]/Au:[M,S,N]/C:[N,P,C]/I:[N,P,C]/A:[N,P,C]"
BASE = parse_vector_template(BS)
TS = "E:[U,POC,F,H,ND]/RL:[OF,TF,W,U,ND]/RC:[UC,UR,C,ND]"
TPRL = parse_vector_template(TS)
ES = "CDP:[N,L,LM,MH,H,ND]/TD:[N,L,M,H,ND]/CR:[L,M,H,ND]/IR:[L,M,H,ND]/AR:[L,M,H,ND]"
EVTL = parse_vector_template(ES)

class InvalidBaseVector(Exception): pass

class VulnerabilityVector:
    def __init__(self, vulnerability_string, metric_seq):
        self.vulnerability_string = vulnerability_string
        self.metric_seq = metric_seq
        self.base_metric_index_set = { idx[1] for idx in metric_seq }
        self.base_metric_index_order = [ idx[1] for idx in metric_seq ]
        self.base = BASE
        self.temporal = TPRL
        self.environmental = EVTL
        self.all = OrderedDict(BASE)
        self.all.update(TPRL)
        self.all.update(EVTL)


    def valid_base_length(self, vulnerability_string = None):
        """Compare with the length of a base vulnerability string.

        If no supplied string, use the string supplied at instance
        creation.  Returns self or raises VulnerabilityVectorError.

        >>> s1 = "AV:A/AC:M/Au:S/C:P/I:C/A:C"
        >>> v1 = VulnerabilityVector(s1)
        >>> v1 == v1.valid_base_length()
        True
        >>> v1.valid_base_length(s1[:-5])
        Traceback (most recent call last):
        ...
        VulnerabilityVectorError: Too few elements in vector

        """
        if not vulnerability_string:
            vec = self.vulnerability_string
        else:
            vec = vulnerability_string

        vec = vec.split("/")
        incorrect_length = len(self.base) - len(vec)
        if incorrect_length:
            msg1 = "Too few" if incorrect_length > 0 else "Too many"
            msg0 = "{1} elements in vector".format(vec, msg1)
            raise VulnerabilityVectorError(msg0)
        return self

    def valid_order(self, vulnerability_string = None):
        """Ensure correct ordering of elements.

        If no supplied string, use the string supplied at instance
        creation.  Returns self or raises VulnerabilityVectorError.

        >>> s1 = "AV:A/AC:M/Au:S/C:P/I:C/A:C"
        >>> v1 = VulnerabilityVector(s1)
        >>> v1 == v1.valid_order()
        True
        >>> s1 = "AC:M/AV:A/Au:S/C:P/I:C/A:C"
        >>> v1.valid_order(s1)
        Traceback (most recent call last):
        ...
        VulnerabilityVectorError: bla blaToo few elements in vector

        """
        if not vulnerability_string:
            vec = self.vulnerability_string
        else:
            vec = vulnerability_string

        vec = list(map(lambda x: x.split(':')[0], vec.split("/")))
        base_keys = list(self.base.keys())
        if vec != base_keys:
            msg0 = "Duplicate elements or" \
                   " incorrect ordering in {0}".format(vec)
            print(msg0)
            #raise VulnerabilityVectorError(msg0)
        return self

    def valid(self):
        """Validate a vulnerability string.

        Each element of the vector is a key-value pair where the key is a
        Metric and the value is the value of MetricValue.  Check that each
        key-value pair is valid.  The key should be one in the set of
        valid Metrics and the value of the key-value pair should also
        be valid.

        """
        vulnerability_vector = self.vulnerability_string.split('/')

        for v in vulnerability_vector:
            try:
                ## Check that idx is a valid metric
                idx, value = v.split(':')
                if idx not in self.all.keys():
                    raise InvalidBaseVector("{0} not a base metric".format(idx))
                ## Check that value is one in the set of allowed metrics
                assert value in self.all[idx], "Not a valid key"
            except AssertionError as e:
                print("{0} {1}:{2}".format(e, idx, value))
                print("{1} must be one of: {2})".format(idx,
                                                      value,
                                                      self.all[idx]))
                sys.exit(1)
            except (KeyError, ValueError, InvalidBaseVector) as e:
                print('Error: invalid vulnerability vector.')
                print('Hint: {}'.format(e))
                sys.exit(1)
        return self

    def complete(self):
        """Ensure vulnerability string is complete.

        In addition to being a valid vulnerability string, the number
        of elements and the order of elements should correspond to the
        expected order represented by the metric_seq.

        """
        self.valid()
        try:
            vulnerability_vector = self.vulnerability_string.split('/')
            self._valid_length(vulnerability_vector)
            self._valid_order(vulnerability_vector)
        except (KeyError, ValueError, InvalidBaseVector) as e:
            print('Error: invalid vulnerability vector.')
            print('Hint: {}'.format(e))
            sys.exit(1)
        return self

    def _valid_length(self, vec):
        valid_base_len = len(self.base)
        valid_temp_len = valid_base_len + len(self.temporal)
        valid_env_len = valid_temp_len + len(self.environmental)
        if (valid_base_len != len(vec) and
            valid_temp_len != len(vec) and
            valid_env_len != len(vec) ):
            msg = "{0} wrong number of elements in vector".format(vec)
            raise InvalidBaseVector(msg)
        return True

    def _valid_order(self, vec):
        for ii, v in enumerate(vec):
            idx, value = v.split(':')
            if idx != self.base_metric_index_order[ii]:
                msg = "{0} duplicate elements or" \
                      " incorrect ordering in vector".format(vec)
                raise InvalidBaseVector(msg)
        return True

    def metric_values(self):
        vulnerability_vector = self.vulnerability_string.split('/')
        selected = []
        for v in vulnerability_vector:
            idx,value = v.split(':')
            selected.append(value)
        return selected



class VulnerabilityVectorError(Exception): pass


if __name__ == "__main__":
    import doctest
    doctest.testmod()
