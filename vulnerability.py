#!/usr/bin/env python3
#
# Author: Fredrik Hedman <fredrik.hedman@noruna.se>
# VERSION: 1.16
# LICENSE: MIT LICENSE
#
"""The VulnerabilityVector class encapsulates the concept of a
vulnerability vector as decribed in the
[CVSS Guide.](http://www.first.org/cvss/cvss-guide.html)

A VulnerabilityVector is initialized with a string containing a
vulnerability vector.  The operations help in checking, modifying and
using the vector.

A vector is a list of components separated by a slash ("/").  Each
component is is a pair of values separated by a colon (":"). The first
value is the abbreviated metric name and the second value is the
abbreviated metric value.

The base, temporal, and environmental vectors are shown below with the
possible metric values listed within square brackets ([...])

* Base
"AV:[L,A,N]/AC:[H,M,L]/Au:[M,S,N]/C:[N,P,C]/I:[N,P,C]/A:[N,P,C]"

* Temporal
"E:[U,POC,F,H,ND]/RL:[OF,TF,W,U,ND]/RC:[UC,UR,C,ND]"

* Environmental
"CDP:[N,L,LM,MH,H,ND]/TD:[N,L,M,H,ND]/CR:[L,M,H,ND]/IR:[L,M,H,ND]/AR:[L,M,H,ND]"

The vector lists these metrics in a predetermined order.

When a temporal or environmental metric is not used it is assigned the
value "ND" (not defined).

"""
import sys
from collections import OrderedDict

def parse_vector_template(txt):
    keys = [ k.split(':')[0] for k in txt.split('/') ]
    vals = [ k.split(':')[1][1:-1].split(',') for k in txt.split('/') ]
    return OrderedDict(zip(keys, vals))

BASE_SCORE = "AV:[L,A,N]/AC:[H,M,L]/Au:[M,S,N]/C:[N,P,C]/I:[N,P,C]/A:[N,P,C]"
TEMPORAL_SCORE = "E:[U,POC,F,H,ND]/RL:[OF,TF,W,U,ND]/RC:[UC,UR,C,ND]"
ENVIRONMENTAL_SCORE = "CDP:[N,L,LM,MH,H,ND]/TD:[N,L,M,H,ND]/CR:[L,M,H,ND]/IR:[L,M,H,ND]/AR:[L,M,H,ND]"

BASE = parse_vector_template(BASE_SCORE)
TEMPORAL = parse_vector_template(TEMPORAL_SCORE)
ENVIRONMENTAL = parse_vector_template(ENVIRONMENTAL_SCORE)

class InvalidBaseVector(Exception): pass
class VulnerabilityVectorError(Exception): pass

class VulnerabilityVector:
    def __init__(self, seq):
        self.vvec = self._parse_vulnerability_string(seq)
        self.vulnerability_string = seq
        self.base = BASE
        self.temporal = TEMPORAL
        self.environmental = ENVIRONMENTAL
        self.all = OrderedDict(BASE)
        self.all.update(TEMPORAL)
        self.all.update(ENVIRONMENTAL)

    def _parse_vulnerability_string(self, seq):
        try:
            d =  OrderedDict(map(lambda x: x.split(":"), seq.split("/")))
            l =  list(map(lambda x: x.split(":"), seq.split("/")))
            if len(d) != len(l):
                msg = "{0} duplicate elements" \
                      " in vector".format(seq)
                raise InvalidBaseVector(msg)
        except (InvalidBaseVector) as e:
            print('Error: invalid vulnerability vector.')
            print('Hint: {}'.format(e))
            raise
        except (ValueError) as e:
            msg00 = "Error in parsing vulnerability vector {0}".format(seq)
            print('{1} : {0}'.format(e, InvalidBaseVector(msg00)))
            raise
        return d

    def valid(self):
        """Validate vulnerability string.

        Each element is a key-value pair where the key is a Metric and
        the value is a MetricValue.  Check that each pair is valid.  The
        key should be one in the set of valid Metrics and the
        corresponding value should be in the set of valid MetricValues.

        """
        for key, value in self.vvec.items():
            try:
                if (key in self.all.keys()) and (value in self.all[key]):
                    continue
                elif key not in self.all.keys():
                    msg00 = "{0} not a metric".format(key)
                elif value not in self.all[key]:
                    msg01 = "Must be one of: {0})".format(self.all[key])
                    msg00 = "{0} not a metric value. {1}".format(value, msg01)
                raise InvalidBaseVector(msg00)
            except InvalidBaseVector as e:
                print('Error: invalid vulnerability vector.')
                print('Hint: {0}'.format(e))
                raise
        return self

    def complete(self):
        """Ensure vulnerability string is complete.

        In addition to being a valid vulnerability string, the number
        of elements and the order of elements should correspond to the
        expected order represented by the metric_seq.

        """
        self.valid()
        try:
            self._valid_length(self.vvec)
            self._valid_order(self.vvec)
        except (InvalidBaseVector) as e:
            print('Error: invalid vulnerability vector.')
            print('Hint: {}'.format(e))
            raise
        return self

    def _valid_length(self, vec):
        valid_base_len = len(self.base)
        valid_temp_len = valid_base_len + len(self.temporal)
        valid_env_len = valid_temp_len + len(self.environmental)
        #print("##", len(vec), valid_base_len, valid_temp_len, valid_env_len)
        if (valid_base_len != len(vec) and
            valid_temp_len != len(vec) and
            valid_env_len != len(vec) ):
            msg = "wrong number of elements in vector"
            raise InvalidBaseVector(msg)
        return True

    def _valid_order(self, vec):
        base_metric_index_order = list(self.all.keys())
        for ii, v in enumerate(vec):
            if v != base_metric_index_order[ii]:
                msg = "{0} duplicate elements or" \
                      " incorrect ordering in vector".format(vec)
                raise InvalidBaseVector(msg)
        return True

    def metric_values(self):
        selected = []
        for idx, value in self.vvec.items():
            selected.append(value)
        return selected


if __name__ == "__main__":
    import doctest
    doctest.testmod()
